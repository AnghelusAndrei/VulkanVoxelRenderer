#version 460

// Compute shader layout
layout(local_size_x = 8, local_size_y = 8) in;


// Constants
const uint maxDepth = 15;

// Specialization constants 

layout(constant_id=0) const uint screenWidth = 800;
layout(constant_id=1) const uint screenHeight = 600;
layout(constant_id=2) const uint octreeDepth=8;

const uvec2 screenSize=uvec2(screenWidth, screenHeight);


layout(std140, set=0, binding=0) uniform UniformBufferObject {
    vec3 position;
    vec3 direction;
    vec3 cameraPlanVector;
    vec3 cameraPlanSurfaceRightVector;
    vec3 cameraPlanSurfaceUpVector;
} ubo;


layout(std430, set=0, binding=1) readonly buffer OctreeBuffer {
    uint data[];
} octree;

layout(std140, set=0, binding=2) writeonly buffer LightingBuffer {
    vec4 data[];
} lighting;
 
layout(rgba8, set=0, binding=3) uniform writeonly image2D OutputImage;

#define max_depth 15
#define f_error 0.0001


uint octreeLength;


const uint isNode_mask=1;
const uint n_count_mask=15;
const uint n_next_mask=2147483632;
const uint l_type_mask=254;
const uint l_data_x_mask=65280;
const uint l_data_y_mask=16711680;
const uint l_data_z_mask=2139095040;
const uint data_mask=4294967040;

struct Node{
    bool isNode; // 1 bit
    uint n_count; // 3 bits
    uint n_next; // 28 bits
    int l_type; // 7 bits
    uvec3 l_data; // 24 bits
};


Node readNode(uint data){
    Node node;
    node.isNode = bool(data & isNode_mask);

    if(node.isNode){
        node.n_count = uint((data & n_count_mask) >> 1);
        node.n_next = uint((data & n_next_mask) >> 4);

        return node;
    }

    node.l_type = int((data & l_type_mask) >> 1);
    node.l_data.x = uint((data >> 8)&0xFF);
    node.l_data.y = uint((data >> 16)&0xFF);
    node.l_data.z = uint((data >> 24)&0xFF);

    return node;
}

bool inBounds(vec3 v, float n) {return 0<=v.x&&v.x<=n &&0<=v.y&&v.y<=n&&0<=v.z&&v.z<n;}
// 1 << (octreeDepth - depth)
uint utils_locate(uvec3 position, uint depth){
    uint p2 = octreeLength>>depth;
    return (int(bool(position.x & p2)) << 2) | (int(bool(position.y & p2)) << 1) | (int(bool(position.z & p2)));
}
bool utils_contained(uvec3 position1, uvec3 position2, uint depth){
    uint p2 = octreeLength>>depth;
    return ((position1.x / p2 == position2.x / p2) && (position1.y / p2 == position2.y / p2) && (position1.z / p2 == position2.z / p2));
}

struct voxel_t{
    bool hit;
    uint id;
    vec3 normal;
};

struct ray_t{
    vec3 origin;
    vec3 direction;

    uint max_steps;
    float max_dist;
};

struct leaf_t{
    uint id;
    uint size;
    vec3 position;
};

uvec3 lookup(uvec3 position, uint q){
    uint offset = 0;
    for (uint depth = 1; depth <= octreeDepth; depth++)
    {
        offset += utils_locate(position, depth);
        Node leaf = readNode(octree.data[offset]);
        if (!leaf.isNode)
            return uvec3(offset, 1<<(octreeDepth-depth), q);
        offset = leaf.n_next;
        q++;
    }
}

vec3 box(ray_t ray){

    vec3 r_pos = ray.origin;
    vec3 x,y,z;
    vec3 v_add;
    int q = 0;

    //intersect bounds
    while(!inBounds(r_pos, octreeLength)){
        if(q>3)return vec3(-1,-1,-1);

        float xD,yD,zD;
        float d = 1e9;

        z.z = (ray.direction.z < 0) ? ((r_pos.z > octreeLength) ? (octreeLength-f_error-r_pos.z) : 1e9) : ((r_pos.z < 0) ? (f_error-r_pos.z) : 1e9);
        y.y = (ray.direction.y < 0) ? ((r_pos.y > octreeLength) ? (octreeLength-f_error-r_pos.y) : 1e9) : ((r_pos.y < 0) ? (f_error-r_pos.y) : 1e9);
        x.x = (ray.direction.x < 0) ? ((r_pos.x > octreeLength) ? (octreeLength-f_error-r_pos.x) : 1e9) : ((r_pos.x < 0) ? (f_error-r_pos.x) : 1e9);

        z.x = (z.z*ray.direction.x)/ray.direction.z;
        z.y = (z.z*ray.direction.y)/ray.direction.z;

        y.x = (y.y*ray.direction.x)/ray.direction.y;
        y.z = (y.y*ray.direction.z)/ray.direction.y;
    
        x.y = (x.x*ray.direction.y)/ray.direction.x;
        x.z = (x.x*ray.direction.z)/ray.direction.x;

        zD = distance(vec3(0,0,0),z);
        yD = distance(vec3(0,0,0),y);
        xD = distance(vec3(0,0,0),x);
        
        if(zD < d){d=zD;v_add=z;}
        if(yD < d){d=yD;v_add=y;}
        if(xD < d){d=xD;v_add=x;}

        if(d>1e8)return vec3(-1,-1,-1);

        
        r_pos += v_add;
        q++;
    }
    return r_pos;
}

voxel_t Raycast_old(ray_t ray){
    voxel_t voxel;

    voxel.hit = false;
    voxel.id = 0;

    /*uint nodeStack[max_depth];
    nodeStack[0] = 0;
    uint offset = 0;
    uint depth = 1;*/
    vec3 l_pos = vec3(0,0,0);
    vec3 r_pos = box(ray);
    leaf_t target;
    //bool inBox = false;

    vec3 normal = vec3(0,0,0);
    vec3 v_add = vec3(0,0,0);
    vec3 x,y,z;
    uint q = 0;

    /*if(inBounds(r_pos, octreeLength)){
        for (depth; depth <= octreeDepth; depth++)
        {
            offset += utils_locate(uvec3(r_pos), depth);

            Node leaf = readNode(octree.data[offset]);
            if(!leaf.isNode){
                if(leaf.l_type == 1){
                    voxel.id = offset;
                    voxel.hit = true;
                    return voxel;
                }
                target.size = 1<<(octreeDepth-depth);
                target.position.x = uint(r_pos.x) - uint(r_pos.x)%target.size;
                target.position.y = uint(r_pos.y) - uint(r_pos.y)%target.size;
                target.position.z = uint(r_pos.z) - uint(r_pos.z)%target.size;
                break;
            }
            nodeStack[depth] = leaf.n_next;
            offset = leaf.n_next;
        }
    }*/

    while(inBounds(r_pos, octreeLength)){
        float d = 1e9;
        float xD,yD,zD;
        //inBox = false;

        x = vec3(0,0,0);
        y = vec3(0,0,0);
        z = vec3(0,0,0);

        //lookup


        uvec3 lookup_results = lookup(uvec3(r_pos), q);
        q = lookup_results.z;

        target.position.x = uint(r_pos.x) - uint(r_pos.x)%lookup_results.y;
        target.position.y = uint(r_pos.y) - uint(r_pos.y)%lookup_results.y;
        target.position.z = uint(r_pos.z) - uint(r_pos.z)%lookup_results.y;


        target.id = lookup_results.x;
        target.size = lookup_results.y;

        Node node = readNode(octree.data[target.id]);
        if(node.l_type == 1){
            voxel.id = target.id;
            voxel.hit = true;
            voxel.normal = normal;
            imageStore(OutputImage, ivec2(gl_GlobalInvocationID.xy), vec4(vec3(float(q)/200),1));
            return voxel;
        }

        v_add = vec3(0,0,0);


        //tree traversal
        x.x = (target.position.x-r_pos.x) + float(ray.direction.x>0)*target.size + sign(ray.direction.x)*f_error;
        x.y = (x.x*ray.direction.y)/ray.direction.x;
        x.z = (x.x*ray.direction.z)/ray.direction.x;

        y.y = (target.position.y-r_pos.y) + float(ray.direction.y>0)*target.size + sign(ray.direction.y)*f_error;
        y.x = (y.y*ray.direction.x)/ray.direction.y;
        y.z = (y.y*ray.direction.z)/ray.direction.y;

        z.z = (target.position.z-r_pos.z) + float(ray.direction.z>0)*target.size + sign(ray.direction.z)*f_error;
        z.x = (z.z*ray.direction.x)/ray.direction.z;
        z.y = (z.z*ray.direction.y)/ray.direction.z;


        zD = distance(vec3(0,0,0),z);
        yD = distance(vec3(0,0,0),y);
        xD = distance(vec3(0,0,0),x);


        if(xD < d){
            d = xD; 
            v_add = x; 
            normal = vec3(-sign(ray.direction.x),0,0);
        }
        if(yD < d){
            d = yD; 
            v_add = y; 
            normal = vec3(0,-sign(ray.direction.y),0);
        }
        if(zD < d){
            d = zD; 
            v_add = z; 
            normal = vec3(0,0,-sign(ray.direction.z));
        }
        
        l_pos = r_pos;
        r_pos += v_add;
        //q++;

        /*while(!utils_contained(uvec3(l_pos), uvec3(r_pos), depth)){
            depth--;
            q++;
        }
        offset = nodeStack[depth];
        depth++;

        for (depth; depth <= octreeDepth; depth++)
        {
            offset += utils_locate(uvec3(r_pos), depth);

            Node leaf = readNode(octree.data[offset]);
            if(!leaf.isNode){
                if(leaf.l_type == 1){
                    voxel.id = offset;
                    voxel.hit = true;
                    imageStore(OutputImage, ivec2(gl_GlobalInvocationID.xy), vec4(vec3(float(q)/200),1));
                    return voxel;
                }
                target.size = 1<<(octreeDepth-depth);
                target.position.x = uint(r_pos.x) - uint(r_pos.x)%target.size;
                target.position.y = uint(r_pos.y) - uint(r_pos.y)%target.size;
                target.position.z = uint(r_pos.z) - uint(r_pos.z)%target.size;
                break;
            }
            nodeStack[depth] = leaf.n_next;
            offset = leaf.n_next;
            q++;
        }*/
    }
    imageStore(OutputImage, ivec2(gl_GlobalInvocationID.xy), vec4(0,0,0,1));
    //if(inBox){imageStore(OutputImage, ivec2(gl_GlobalInvocationID.xy), vec4(0,0,1,1));}
    //imageStore(OutputImage, ivec2(gl_GlobalInvocationID.xy), vec4(0,1,0,1));
    return voxel;
}

voxel_t Raycast(ray_t ray){
    voxel_t voxel;

    voxel.hit = false;
    voxel.id = 0;

    uint nodeStack[max_depth];
    nodeStack[0] = 0;
    uint offset = 0;
    uint depth = 1;
    vec3 l_pos = vec3(0,0,0);
    vec3 r_pos = box(ray);
    leaf_t target;
    //bool inBox = false;

    vec3 normal = vec3(0,0,0);
    vec3 v_add = vec3(0,0,0);
    vec3 x,y,z;
    uint q = 0;

    if(inBounds(r_pos, octreeLength)){
        for (depth; depth <= octreeDepth; depth++)
        {
            offset += utils_locate(uvec3(r_pos), depth);

            Node leaf = readNode(octree.data[offset]);
            if(!leaf.isNode){
                if(leaf.l_type == 1){
                    voxel.id = offset;
                    voxel.hit = true;
                    imageStore(OutputImage, ivec2(gl_GlobalInvocationID.xy), vec4(vec4(vec3(float(q)/200),1)));
                    return voxel;
                }
                target.size = 1<<(octreeDepth-depth);
                target.position.x = uint(r_pos.x) - uint(r_pos.x)%target.size;
                target.position.y = uint(r_pos.y) - uint(r_pos.y)%target.size;
                target.position.z = uint(r_pos.z) - uint(r_pos.z)%target.size;
                break;
            }
            nodeStack[depth] = leaf.n_next;
            offset = leaf.n_next;
            q++;
        }
    }

    while(inBounds(r_pos, octreeLength)){
        float d = 1e9;
        float xD,yD,zD;
        //inBox = false;

        x = vec3(0,0,0);
        y = vec3(0,0,0);
        z = vec3(0,0,0);

        //lookup


        /*uvec2 lookup_results = lookup(uvec3(r_pos));

        target.position.x = uint(r_pos.x) - uint(r_pos.x)%lookup_results.y;
        target.position.y = uint(r_pos.y) - uint(r_pos.y)%lookup_results.y;
        target.position.z = uint(r_pos.z) - uint(r_pos.z)%lookup_results.y;


        target.id = lookup_results.x;
        target.size = lookup_results.y;

        Node node = readNode(octree.data[target.id]);
        if(node.l_type == 1){
            voxel.id = target.id;
            voxel.hit = true;
            voxel.normal = normal;
            return voxel;
        }*/

        v_add = vec3(0,0,0);


        //tree traversal
        x.x = (target.position.x-r_pos.x) + float(ray.direction.x>0)*target.size + sign(ray.direction.x)*f_error;
        x.y = (x.x*ray.direction.y)/ray.direction.x;
        x.z = (x.x*ray.direction.z)/ray.direction.x;

        y.y = (target.position.y-r_pos.y) + float(ray.direction.y>0)*target.size + sign(ray.direction.y)*f_error;
        y.x = (y.y*ray.direction.x)/ray.direction.y;
        y.z = (y.y*ray.direction.z)/ray.direction.y;

        z.z = (target.position.z-r_pos.z) + float(ray.direction.z>0)*target.size + sign(ray.direction.z)*f_error;
        z.x = (z.z*ray.direction.x)/ray.direction.z;
        z.y = (z.z*ray.direction.y)/ray.direction.z;


        zD = distance(vec3(0,0,0),z);
        yD = distance(vec3(0,0,0),y);
        xD = distance(vec3(0,0,0),x);


        if(xD < d){
            d = xD; 
            v_add = x; 
            normal = vec3(-sign(ray.direction.x),0,0);
        }
        if(yD < d){
            d = yD; 
            v_add = y; 
            normal = vec3(0,-sign(ray.direction.y),0);
        }
        if(zD < d){
            d = zD; 
            v_add = z; 
            normal = vec3(0,0,-sign(ray.direction.z));
        }
        
        l_pos = r_pos;
        r_pos += v_add;
        //q++;

        if(inBounds(r_pos, octreeLength)){


            while(!utils_contained(uvec3(l_pos), uvec3(r_pos), depth)){
                depth--;
                q++;
            }
            offset = nodeStack[depth];
            depth++;

            for (depth; depth <= octreeDepth; depth++)
            {
                offset += utils_locate(uvec3(r_pos), depth);

                Node leaf = readNode(octree.data[offset]);
                if(!leaf.isNode){
                    if(leaf.l_type == 1){
                        voxel.id = offset;
                        voxel.hit = true;
                        imageStore(OutputImage, ivec2(gl_GlobalInvocationID.xy), vec4(vec3(float(q)/200),1));
                        return voxel;
                    }
                    target.size = 1<<(octreeDepth-depth);
                    target.position.x = uint(r_pos.x) - uint(r_pos.x)%target.size;
                    target.position.y = uint(r_pos.y) - uint(r_pos.y)%target.size;
                    target.position.z = uint(r_pos.z) - uint(r_pos.z)%target.size;
                    break;
                }
                nodeStack[depth] = leaf.n_next;
                offset = leaf.n_next;
                q++;
            }
        }else{
            imageStore(OutputImage, ivec2(gl_GlobalInvocationID.xy), vec4(0,0,0,1));
        }
    }
    imageStore(OutputImage, ivec2(gl_GlobalInvocationID.xy), vec4(0,0,0,1));
    //if(inBox){imageStore(OutputImage, ivec2(gl_GlobalInvocationID.xy), vec4(0,0,1,1));}
    //imageStore(OutputImage, ivec2(gl_GlobalInvocationID.xy), vec4(0,1,0,1));
    return voxel;
}


vec4 packIndex(uint index) {
    float x = uintBitsToFloat(index & 0xFF000000);
    float y = uintBitsToFloat(index & 0x00FF0000);
    float z = uintBitsToFloat(index & 0x0000FF00);
    float w = uintBitsToFloat(index & 0x000000FF);
    vec4 result = vec4(x,y,z,w);
    return result;
}

void main()
{
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

    octreeLength = 1<<octreeDepth;

    vec2 camera_plan_position = vec2(2 * (float(pixel_coords.x) / float(screenWidth)) - 1, 2 * (float(pixel_coords.y) / float(screenHeight)) - 1);
    vec3 vector_to_point = normalize(ubo.cameraPlanVector + camera_plan_position.x * ubo.cameraPlanSurfaceRightVector - camera_plan_position.y * ubo.cameraPlanSurfaceUpVector);
    
    vec3 color = vec3(0,0,0);

    ray_t Ray;
    Ray.origin = ubo.position;
    Ray.direction = vector_to_point;
    Ray.max_dist = 5000;
    Ray.max_steps = 1000;

    //if(box(Ray).x < 0)color += vec3(1,0,0);

    voxel_t voxel = Raycast(Ray);

    /*if(voxel.hit){
        Node voxel_node = readNode(octree.data[voxel.id]);
        color += vec3(voxel_node.l_data.z/255.0,voxel_node.l_data.y/255.0,voxel_node.l_data.x/255.0);
        /*color -= vec3(0.3);
        color += vec3(0.3) * voxel.normal.x;
        color += vec3(0.2) * voxel.normal.y;
        color += vec3(0.1) * voxel.normal.z;
    }

    imageStore(OutputImage, pixel_coords, vec4(color,1));*/



    //imageStore(OutputImage, pixel_coords, packIndex(voxel.id));
}