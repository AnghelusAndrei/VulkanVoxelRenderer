#version 460
layout(local_size_x = 16, local_size_y = 16) in;

layout(constant_id=0) const uint screenWidth = 800;
layout(constant_id=1) const uint screenHeight = 600;
const uvec2 screenSize=uvec2(screenWidth, screenHeight);
layout(set=0, binding=0) uniform UniformBufferObject {
    int test;
} ubo;
layout(std140, set=0, binding=1) readonly buffer OctreeBuffer {
    uint data[];
} octree;

layout(std140, set=0, binding=2) writeonly buffer LightingBuffer {
    vec4 data[];
} lighting;
 
layout(rgba8, set=0, binding=3) uniform writeonly image2D OutputImage;

#define max_depth 15
#define f_error = 0.001

uint utils_p2r[max_depth];

struct OctreeData_t{
    uint depth;
    uint n;
} OctreeData;

struct Node{
    bool isNode; // 1 bit

    int n_count; // 3 bits
    uint n_next; // 28 bits

    int l_type; // 7 bits
    uvec3 l_data; // 24 bits
};

Node readNode(uint data){
    Node node;
    node.isNode = bool(data >> 31);

    if(node.isNode){
        node.n_count = int(data << 1 >> 29);
        node.n_next = uint(data << 4 >> 4);

        return node;
    }

    node.l_type = int(data << 1 >> 25);
    node.l_data.x = uint(data << 8*1 >> 8*3);
    node.l_data.y = uint(data << 8*2 >> 8*3);
    node.l_data.z = uint(data << 8*3 >> 8*3);

    return node;
}

#define semn(x)((x>=0) ? 1 : -1)
bool inBounds(vec3 v, float n) {return 0<=v.x&&v.x<=n &&0<=v.y&&v.y<=n&&0<=v.z&&v.z<n;}

uint utils_locate(uvec3 position, uint depth)
{
    return (int(bool(position.x & utils_p2r[depth])) << 2) | (int(bool(position.y & utils_p2r[depth])) << 1) | (int(bool(position.z & utils_p2r[depth])));
}
bool utils_contained(uvec3 position1, uvec3 position2, uint depth){
    return ((position1.x / utils_p2r[depth] == position2.x / utils_p2r[depth]) && (position1.y / utils_p2r[depth] == position2.y / utils_p2r[depth]) && (position1.z / utils_p2r[depth] == position2.z / utils_p2r[depth]));
}



struct voxel_t{
    bool hit;
    uint id;
};

struct ray_t{
    vec3 origin;
    vec3 direction;

    uint max_steps;
    float max_dist;
};

voxel_t Raycast(ray_t ray){
    voxel_t voxel;

    voxel.hit = false;
    voxel.id = 0;

    uint nodeStack[max_depth];
    uint offset = 0;
    uint depth = 1;

    vec3 r_pos = ray.origin;
    vec3 l_pos;

    vec3 normal = {0,0,0};
    vec3 r_add  = {0,0,0};
    vec3 x,y,z;
    uint q = 0;

    if(inBounds(r_pos, OctreeData.n)){
        for (depth; depth <= OctreeData.depth; depth++)
        {
            offset += utils_locate(uint(r_pos), depth);

            Node leaf = readNode(octree.data[offset]);
            if(!leaf.isNode){
                if(leaf.l_type == 1){
                    voxel.id = offset;
                    voxel.hit = true;
                    return voxel;
                }
                break;
            }
            nodeStack[depth] = leaf.n_next;
            offset = leaf.n_next;
        }
    }


    for(q;q<ray.max_steps;++q){
        float d = 1e9;
        float xD,yD,zD;

        x = vec3(0,0,0);
        y = vec3(0,0,0);
        z = vec3(0,0,0);
        r_add = vec3(0,0,0);

        //intersect bounds
        if(!inBounds(r_pos, OctreeData.n)){
            bvec3 notfound = bvec3(0,0,0);

            if(r_pos.x < 0){
                if(ray.direction.x <= 0)notfound.x = true;
                else x.x = -r_pos.x + semn(ray.direction.x)*f_error;
            }else if(r_pos.x > OctreeData.n){
                if(ray.direction.x >= 0)notfound.x = true;
                else x.x = OctreeData.n-r_pos.x + semn(ray.direction.x)*f_error;
            }

            if(r_pos.y < 0){
                if(ray.direction.y <= 0)notfound.y = true;
                else y.y = -r_pos.y + semn(ray.direction.y)*f_error;
            }else if(r_pos.y > OctreeData.n){
                if(ray.direction.y >= 0)notfound.y = true;
                else y.y = OctreeData.n-r_pos.y + semn(ray.direction.y)*f_error;
            }

            if(r_pos.z < 0){
                if(ray.direction.z <= 0)notfound.z = true;
                else z.z = -r_pos.z + semn(ray.direction.z)*f_error;
            }else if(r_pos.z > OctreeData.n){
                if(ray.direction.z >= 0)notfound.z = true;
                else z.z = OctreeData.n-r_pos.z + semn(ray.direction.z)*f_error;
            }

            voxel.hit = false;

            if(!notfound.x){
                voxel.hit = true;
                x.y = (x.x*ray.direction.y)/ray.direction.x;
                x.z = (x.x*ray.direction.z)/ray.direction.x;
            }else{
                x.x = 1e8;
            }

            if(!notfound.y){
                voxel.hit = true;
                y.x = (y.y*ray.direction.x)/ray.direction.y;
                y.z = (y.y*ray.direction.z)/ray.direction.y;
            }else{
                y.y = 1e8;
            }

            if(!notfound.z){
                voxel.hit = true;
                z.x = (z.z*ray.direction.x)/ray.direction.z;
                z.y = (z.z*ray.direction.y)/ray.direction.z;
            }else{
                z.z = 1e8;
            }

            if(voxel.hit != true)
                return voxel;
            
            voxel.hit = false;


            if(length(x) < length(y) && length(x) < length(z))r_add = x;
            else if(length(y) < length(x) && length(y) < length(z))r_add = y;
            else r_add = z;


            

            for (depth; depth <= OctreeData.depth; depth++)
            {
                offset += utils_locate(r_pos, depth);

                Node leaf = readNode(octree.data[offset]);
                if(!leaf.isNode){
                    if(leaf.l_type == 1){
                        voxel.id = offset;
                        voxel.hit = true;
                        return voxel;
                    }
                    break;
                }
                nodeStack[depth] = leaf.n_next;
                offset = leaf.n_next;
            }
        }

        //lookup
        while(!utils_contained(l_pos, r_pos, depth)){
            depth--;
        }

        offset = nodeStack[depth];
        depth++;

        for (depth; depth <= OctreeData.depth; depth++)
        {
            offset += utils_locate(r_pos, depth);

            Node leaf = readNode(octree.data[offset]);
            if(!leaf.isNode){
                if(leaf.l_type == 1){
                    voxel.id = offset;
                    voxel.hit = true;
                    return voxel;
                }
                break;
            }
            nodeStack[depth] = leaf.n_next;
            offset = leaf.n_next;
        }


        //tree traversal
        x.x = (target.position.x-r_pos.x) + float(ray.direction.x>0)*target.size + semn(ray.direction.x)*f_error;
        x.y = (x.x*ray.direction.y)/ray.direction.x;
        x.z = (x.x*ray.direction.z)/ray.direction.x;

        y.y = (target.position.y-r_pos.y) + float(ray.direction.y>0)*target.size + semn(ray.direction.y)*f_error;
        y.x = (y.y*ray.direction.x)/ray.direction.y;
        y.z = (y.y*ray.direction.z)/ray.direction.y;

        z.z = (target.position.z-r_pos.z) + float(ray.direction.z>0)*target.size + semn(ray.direction.z)*f_error;
        z.x = (z.z*ray.direction.x)/ray.direction.z;
        z.y = (z.z*ray.direction.y)/ray.direction.z;


        xD = sqrt(x.x*x.x + x.y*x.y + x.z*x.z);
        yD = sqrt(y.x*y.x + y.y*y.y + y.z*y.z);
        zD = sqrt(z.x*z.x + z.y*z.y + z.z*z.z);

        if(xD < d){
            d = xD; 
            v_add = x; 
            normal = (vec3){-semn(direction.x),0,0};
        }
        if(yD < d){
            d = yD; 
            v_add = y; 
            normal = (vec3){0,-semn(direction.y),0};
        }
        if(zD < d){
            d = zD; 
            v_add = z; 
            normal = (vec3){0,0,-semn(direction.z)};
        }
        
        l_pos = r_pos;
        r_pos += v_add;
    }
    return voxel;
}


void main()
{
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

    uint p2r = 1;
    for (int i = OctreeData.depth; i >= 1; i--)
    {
        utils_p2r[i] = p2r;
        p2r <<= 1;
    }

    ray_t Ray;
    voxel_t voxel = Raycast(Ray);

    imageStore(OutputImage, pixel_coords, packIndex(0));
}