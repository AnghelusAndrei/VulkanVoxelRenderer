#version 460
layout(local_size_x = 16, local_size_y = 16) in;

layout(constant_id=0) const uint screenWidth = 800;
layout(constant_id=1) const uint screenHeight = 600;
const uvec2 screenSize=uvec2(screenWidth, screenHeight);
layout(set=0, binding=0) uniform UniformBufferObject {
    int test;
} ubo;
layout(std140, set=0, binding=1) readonly buffer OctreeBuffer {
    uint data[];
} octree;

layout(std140, set=0, binding=2) writeonly buffer LightingBuffer {
    vec4 data[];
} lighting;
 
layout(rgba8, set=0, binding=3) uniform writeonly image2D OutputImage;

#define max_depth 15

vec4 packIndex(uint index) {
    float x = uintBitsToFloat(index & 0xFF000000);
    float y = uintBitsToFloat(index & 0x00FF0000);
    float z = uintBitsToFloat(index & 0x0000FF00);
    float w = uintBitsToFloat(index & 0x000000FF);
    vec4 result = vec4(x,y,z,w);
    return result;
}

#define semn(x)((x>=0) ? 1 : -1)
bool inBounds(vec3 v, float n) {return 0<=v.x&&v.x<=n &&0<=v.y&&v.y<=n&&0<=v.z&&v.z<n;}
struct Hit { float tmin; float tmax; }

vec3 box(vec3 ray_origin, vec3 ray_dir, vec3 minpos, vec3 maxpos) {
  vec3 inverse_dir = 1.0 / ray_dir;
  vec3 tbot = inverse_dir * (minpos - ray_origin);
  vec3 ttop = inverse_dir * (maxpos - ray_origin);
  vec3 tmin = min(ttop, tbot);
  vec3 tmax = max(ttop, tbot);
  vec2 traverse = max(tmin.xx, tmin.yz);
  float traverselow = max(traverse.x, traverse.y);
  traverse = min(tmax.xx, tmax.yz);
  float traversehi = min(traverse.x, traverse.y);
  return vec3(float(traversehi > max(traverselow, 0.0)), traversehi, traverselow);
}
int octree_l;
#define f_error = 0.001

struct leaf_t{
    uint id;
    uint size;
    vec3 position;
};

struct voxel_t{
    bool hit;
    uint id;
};

struct ray_t{
    vec3 origin;
    vec3 direction;

    uint max_steps;
    float max_dist;
};

voxel_t Raycast(ray_t ray){
    voxel_t voxel;

    voxel.hit = false;
    voxel.id = 0;

    uint nodeStack[max_depth];

    vec3 r_pos = ray.origin;

    vec3 normal = {0,0,0};
    vec3 r_add  = {0,0,0};
    ivec3 found = {1,1,1};
    vec3 x,y,z;
    uint q = 0;

    for(q;q<ray.max_steps;++q){
        float d = 1e9;
        float xD,yD,zD;

        x = vec3(0,0,0);
        y = vec3(0,0,0);
        z = vec3(0,0,0);
        r_add = {0,0,0};

        //intersect bounds
        if(!inBounds(r_pos, octree_l)){
            vec3 boxllc = vec3(0);
            vec3 boxurc = vec3(octree_l);

            vec3 boxctr = (boxllc + boxurc) / 2.0;
            vec3 box = box(r_pos, ray.direction, boxllc, boxurc);

            float is_box_hit = box.x;
            float box_t_max = box.y;
            float box_t_min = box.z;
            if(!is_box_hit)return voxel;

            r_pos += ((r_pos<0) ? box_t_min : box_t_max) * ray.direction;
        }

        //lookup
        leaf_t target;


        //tree traversal
        x.x = (target.position.x-r_pos.x) + float(ray.direction.x>0)*target.size + semn(ray.direction.x)*f_error;
        x.y = (x.x*ray.direction.y)/ray.direction.x;
        x.z = (x.x*ray.direction.z)/ray.direction.x;

        y.y = (target.position.y-r_pos.y) + float(ray.direction.y>0)*target.size + semn(ray.direction.y)*f_error;
        y.x = (y.y*ray.direction.x)/ray.direction.y;
        y.z = (y.y*ray.direction.z)/ray.direction.y;

        z.z = (target.position.z-r_pos.z) + float(ray.direction.z>0)*target.size + semn(ray.direction.z)*f_error;
        z.x = (z.z*ray.direction.x)/ray.direction.z;
        z.y = (z.z*ray.direction.y)/ray.direction.z;


        xD = sqrt(x.x*x.x + x.y*x.y + x.z*x.z);
        yD = sqrt(y.x*y.x + y.y*y.y + y.z*y.z);
        zD = sqrt(z.x*z.x + z.y*z.y + z.z*z.z);

        if(xD < d){
            d = xD; 
            v_add = x; 
            normal = (vec3){-semn(direction.x),0,0};
        }
        if(yD < d){
            d = yD; 
            v_add = y; 
            normal = (vec3){0,-semn(direction.y),0};
        }
        if(zD < d){
            d = zD; 
            v_add = z; 
            normal = (vec3){0,0,-semn(direction.z)};
        }
        

        ray += v_add;
    }
    return voxel;
}


void main()
{
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

    ray_t Ray;
    voxel_t voxel = Raycast(Ray);

    imageStore(OutputImage, pixel_coords, packIndex(0));
}